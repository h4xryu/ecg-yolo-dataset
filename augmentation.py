import cv2
import os
import numpy as np
import random
from tqdm import tqdm
import time

from scipy.stats import norm
import shutil
from sklearn.model_selection import train_test_split


# 전역 변수 설정
rectangles = []  # 사각형 좌표를 저장할 리스트
start_point = None
end_point = None
drawing = False
delete_mode = False  # 삭제 모드 플래그
image = None
img_copy = None
img_with_text = None  # 텍스트가 추가된 이미지


# SHADOW ###############################################################################################################
def generate_spot_light_mask(
    mask_size,
    position=None,
    max_brightness=255,
    min_brightness=0,
    mode="gaussian",
    linear_decay_rate=None,
    speedup=False,
):
    """
    Generate decayed light mask generated by spot light given position, direction. Multiple spotlights are accepted.
    Args:
        mask_size: tuple of integers (w, h) defining generated mask size
        position: list of tuple of integers (x, y) defining the center of spotlight light position,
                  which is the reference point during rotating
        max_brightness: integer that max brightness in the mask
        min_brightness: integer that min brightness in the mask
        mode: the way that brightness decay from max to min: linear or gaussian
        linear_decay_rate: only valid in linear_static mode. Suggested value is within [0.2, 2]
        speedup: use `shrinkage then expansion` strategy to speed up vale calculation
    Return:
        light_mask: ndarray in float type consisting value from max_brightness to min_brightness. If in 'linear' mode
                    minimum value could be smaller than given min_brightness.
    """
    if position is None:
        position = [(random.randint(0, mask_size[0]), random.randint(0, mask_size[1]))]
    if linear_decay_rate is None:
        if mode == "linear_static":
            linear_decay_rate = random.uniform(0.25, 1)
    assert mode in [
        "linear",
        "gaussian",
    ], "mode must be linear_dynamic, linear_static or gaussian"
    mask = np.zeros(shape=(mask_size[1], mask_size[0]), dtype=np.float32)
    if mode == "gaussian":
        mu = np.sqrt(mask.shape[0] ** 2 + mask.shape[1] ** 2)
        dev = mu / 3.5
        mask = _decay_value_radically_norm_in_matrix(
            mask_size, position, max_brightness, min_brightness, dev
        )
    mask = np.asarray(mask, dtype=np.uint8)
    # add median blur
    mask = cv2.medianBlur(mask, 5)
    mask = 255 - mask
    # cv2.imshow("mask", mask)
    # cv2.waitKey(0)
    return mask


def _decay_value_radically_norm_in_matrix(
    mask_size, centers, max_value, min_value, dev
):
    """
    _decay_value_radically_norm function in matrix format
    """
    center_prob = norm.pdf(0, 0, dev)
    x_value_rate = np.zeros((mask_size[1], mask_size[0]))
    for center in centers:
        coord_x = np.arange(mask_size[0])
        coord_y = np.arange(mask_size[1])
        xv, yv = np.meshgrid(coord_x, coord_y)
        dist_x = xv - center[0]
        dist_y = yv - center[1]
        dist = np.sqrt(np.power(dist_x, 2) + np.power(dist_y, 2))
        x_value_rate += norm.pdf(dist, 0, dev) / center_prob
    mask = x_value_rate * (max_value - min_value) + min_value
    mask[mask > 255] = 255
    return mask


def _decay_value_radically_norm(x, centers, max_value, min_value, dev):
    """
    Calculate point value decayed from center following Gaussian decay. If multiple centers are given, value
    from each center sums up while limiting the accumulated value into [0, 255]
    NOTE: assuming light at each center is identical: same brightness and same decay rate
    """
    center_prob = norm.pdf(0, 0, dev)
    x_value_rate = 0
    for center in centers:
        distance = np.sqrt((center[0] - x[0]) ** 2 + (center[1] - x[1]) ** 2)
        x_value_rate += norm.pdf(distance, 0, dev) / center_prob
    x_value = x_value_rate * (max_value - min_value) + min_value
    x_value = 255 if x_value > 255 else x_value
    return x_value


def add_spot_light(
    image,
    light_position=None,
    max_brightness=255,
    min_brightness=0,
    mode="gaussian",
    linear_decay_rate=None,
    transparency=None,
):
    """
    Add mask generated from spot light to given image
    """
    if transparency is None:
        transparency = random.uniform(0.5, 0.85)
    frame = np.copy(image)
    height, width, _ = frame.shape
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = generate_spot_light_mask(
        mask_size=(width, height),
        position=light_position,
        max_brightness=max_brightness,
        min_brightness=min_brightness,
        mode=mode,
        linear_decay_rate=linear_decay_rate,
    )
    hsv[:, :, 2] = hsv[:, :, 2] * transparency + mask * (1 - transparency)
    frame = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    frame[frame > 255] = 255
    frame = np.asarray(frame, dtype=np.uint8)
    return frame


def get_shadow(image_list):
    shadowed_list = []
    for image in image_list:
        shadowed_list.append(add_spot_light(image))
    return shadowed_list


# WARP #################################################################################################################


def warp_image(image: np.ndarray, amplitude_x: float = 5, amplitude_y: float = 5):
    # 원본 이미지 크기 가져오기
    height, width = image.shape[:2]

    # 사인파 주기 설정
    frequency_x = 1 / (width / 2)  # 수평 방향 주기를 이미지 폭의 한 파장으로 설정
    frequency_y = 1 / height  # 수직 방향 주기를 이미지 높이의 반파장으로 설정

    # 여유 공간을 추가하여 잘리는 부분 방지
    new_height = int(height + 2 * amplitude_y)
    new_width = int(width + 2 * amplitude_x)
    warped_image = np.zeros(
        (new_height, new_width, *image.shape[2:]), dtype=image.dtype
    )

    # 이미지 중심 위치 계산
    y_offset = amplitude_y
    x_offset = amplitude_x

    # 각 픽셀 위치를 사인 함수에 따라 이동
    for y in range(height):
        for x in range(width):
            # 사인 함수를 사용하여 수평 및 수직 이동량 계산
            offset_x = int(
                amplitude_x * np.sin(2 * np.pi * frequency_y * y)
            )  # 높이 기준 반파장
            offset_y = int(
                amplitude_y * np.sin(2 * np.pi * frequency_x * x)
            )  # 폭 기준 한 파장

            # 새로운 좌표에 이미지 픽셀 배치 (여유 공간을 포함한 좌표)
            new_x = x + x_offset + offset_x
            new_y = y + y_offset + offset_y

            # 좌표가 유효한 범위 내에 있을 때만 픽셀 배치
            if 0 <= new_x < new_width and 0 <= new_y < new_height:
                warped_image[new_y, new_x] = image[y, x]

    return warped_image


def get_warp(image_list):
    warped_list = []
    for image in image_list:
        warped_list.append(warp_image(image))
    return warped_list


version = "kitdataVersion_1_flipped"

if __name__ == "__main__":

    image_directory = os.path.join("F:\\data_set_yolov7", version, "train", "images")
    label_directory = os.path.join("F:\\data_set_yolov7", version, "train", "labels")
    output_image_directory = os.path.join(
        "F:\\data_set_yolov7", version, "augmented", "images"
    )
    output_label_directory = os.path.join(
        "F:\\data_set_yolov7", version, "augmented", "labels"
    )

    os.makedirs(output_label_directory, exist_ok=True)
    os.makedirs(output_image_directory, exist_ok=True)

    support_txt = "F:\\data_set_yolov7\\Vversion\\train\\label"

    image_files = [
        f for f in os.listdir(image_directory) if f.endswith((".jpg", ".png", ".jpeg"))
    ]  # 이미지 파일
    label_files = [
        f for f in os.listdir(label_directory) if f.endswith(".txt")
    ]  # 라벨 파일

    # 라벨과 이미지 매칭 확인
    matched_files = []
    for label_file in label_files:
        image_name = os.path.splitext(label_file)[0]  # 라벨 파일에서 확장자 제거
        for image_file in image_files:
            if image_name == os.path.splitext(image_file)[0]:
                matched_files.append((label_file, image_file))
                break

    # augmentaion 시킬 파일 분리
    origin_set, augmented_set = train_test_split(
        matched_files, test_size=0.3, random_state=42
    )

    for label_file, image_file in tqdm(
        augmented_set, total=len(augmented_set), desc="Processing"
    ):
        img = cv2.imread(os.path.join(image_directory, image_file))
        augimg = img.copy()
        augimg = add_spot_light(image=augimg)
        augimg = warp_image(
            augimg, amplitude_x=random.randint(2, 5), amplitude_y=random.randint(2, 5)
        )
        # cv2.namedWindow("Image", flags=cv2.WINDOW_NORMAL)
        # cv2.resizeWindow("Image", width=1280, height=740)
        # cv2.imshow("Image", augimg)
        # key = cv2.waitKey(0)
        # if key == 27:  # ESC 키를 누르면 중단
        #     break
        # cv2.destroyAllWindows()
        cv2.imwrite(os.path.join(output_image_directory, f"aug-{image_file}"), augimg)

        shutil.copy(
            src=os.path.join(label_directory, label_file),
            dst=os.path.join(output_label_directory, f"aug-{label_file}"),
        )

        # shutil.copy(
        #     src=os.path.join(image_directory, image_file),
        #     dst=os.path.join(output_image_directory, f'aug-{image_file}')
        # )

        # print(f"augmentation 완료: {image_file} 및 {label_file}")

    # for image in image_list:
    #     if image is None:
    #         print("Error: 이미지를 로드할 수 없습니다.")
    #     cv2.namedWindow("Image", flags=cv2.WINDOW_NORMAL)
    #     cv2.resizeWindow("Image", width=1280, height=740)
    #     cv2.imshow("Image", image)
    #     cv2.waitKey(0)
    #     cv2.destroyAllWindows()

    # for file_name in file_list:
    #     augpb = random.randrange(0,10)
    #     image_path = f"{image_directory}/{file_name}"
    #     augimg_path = f"{image_directory}/{file_name}-aug"
    #     txt_path = f"{label_directory}/{file_name.split('.')[0]}.txt"
    #     # print(os.path.join(support_txt,file_name))
    #     # image = cv2.imread(image_path)
    #
    #     if augpb >= 7:
    #         augimg = image.copy()
    #         augimg = add_spot_light(image=augimg)
    #         augimg = warp_image(image=augimg, amplitude_x=random.randrange(0,6),amplitude_y=random.randrange(0,6))
    #         cv2.imwrite(augimg_path, augimg)
    #     cv2.imwrite(image_path, image)
